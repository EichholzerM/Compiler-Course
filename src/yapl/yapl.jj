/**** YAPL Compiler
*
*	Copyright 2010 Daniel Hölbling, Klagenfurt University
*
*	Licensed under the Apache License, Version 2.0 (the "License");
*	you may not use this file except in compliance with the License.
*	You may obtain a copy of the License at
*
*		http://www.apache.org/licenses/LICENSE-2.0
*       
*	Unless required by applicable law or agreed to in writing, software
*	distributed under the License is distributed on an "AS IS" BASIS,
*	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
*	See the License for the specific language governing permissions and
*	limitations under the License.
***/
options {
  JDK_VERSION = "1.5";
  static = true;
}
PARSER_BEGIN(yapl)
package yapl;
import yapl.interfaces.*;
import yapl.lib.*;
import java.util.*;
import yapl.exceptions.*;
import yapl.interfaces.Symbol.SymbolKind;
import yapl.types.*;
public class yapl {
  private static Symboltable symbolTable = new SymboltableImpl();
  private static CodeGen codeGen = new CodeGenImpl();

  public void clear()  {  	symbolTable = new SymboltableImpl();
  	codeGen = new CodeGenImpl();
  }
}
PARSER_END(yapl)

SKIP :
{
 	" "
|	"\r"
|	"\t"
|	"\n"
}

SPECIAL_TOKEN :
{
	< COMMENT : ("/*" (~["*"] | "*" ~["/"])* "*/") >
}

TOKEN:
{
  <# LETTER : (["A"-"Z"] | ["a"-"z"] | "_" ) > |
  <# DIGIT : (["0"-"9"]) > |
  <# OTHERCHAR: ("+" | "-" | "*" | "/" | "." | "," | ";" | ":" | "!"
| "?" | "=" | "#" | "%" | "<" | ">" | "$" | "(" | ")"
| "[" | "]" | "{" | "}" | "\\" | "@" | "&" | "^" | "|") >}



TOKEN :
{
  	< NEW: "new" > |
	< AND: "And" > |
	< OR: "Or" > |
	< DECLARE : "Declare" > |
	< PROGRAM : "Program" > |
	< BEGIN : "Begin" > |
	< END: "End" > |
	< IF : "If" > |
	< THEN : "Then" > |
	< ELSE : "Else" > |
	< ENDIF : "EndIf" > |
	< WHILE : "While" > |
	< CONST : "Const" > |
	< DO : "Do" > |
	< ENDWHILE : "EndWhile" > |
	< RETURN : "Return" > |
	< WRITE : "Write" > |
	< READONLY : "Readonly" > |
	< PROCEDURE : "Procedure" > |
	< TRUE : "True" > |
	< FALSE : "False" > |
	< INTEGER :  "Integer" > |
  	< BOOLEAN : "Boolean" > |	< IDENT : < LETTER > (< LETTER > | < DIGIT >)* > |
	< NUMBER: (< DIGIT >)+ > |
	< STRING: "\"" ( " " | < LETTER > | < DIGIT > | < OTHERCHAR > )* "\"" > 
}

Type Literal() throws YAPLException :
{
  Type t;}
{
  < TRUE >  {
    return new BooleanType();  } | < FALSE >
  {
    return new BooleanType();  } | < NUMBER >
  {
    return new IntegerType();  }}

void PredefinedProcedures() throws YAPLException :
{}
{
  (PredefProc())*}
void PredefProc() throws YAPLException :
{
  Token t;
  Type type = null;
  List<Symbol> parameters = null; 
}
{
  < PROCEDURE > t = < IDENT >
  {
    Symbol symbol = new SymbolImpl(t.image, Symbol.SymbolKind.Procedure);
    symbolTable.addSymbol(symbol);
    symbolTable.openScope(true);
    symbolTable.setParentSymbol(symbol);
  } "(" (parameters = FormalParamList())? ")"
  (":" type = Type())? ";"
  {
    if (parameters != null)
    	symbol.setParameters(parameters);
    symbol.setType(type);
    symbolTable.closeScope();
  }}

Type Type() throws YAPLException :
{
  Type type;
}{
  (< INTEGER >  {    type = new IntegerType();  }  | < BOOLEAN >  {
    type = new BooleanType();  }) ( "[" "]"  {
    type = new ArrayType(type);  })*
  {
    return type;  }}
Attrib Selector(Attrib a) throws YAPLException :
{
Token errorToken;
Token errorToken2;
Attrib index;}
{
  errorToken = "[" index = Expr() errorToken2 = "]" (a = Selector(a))?
  {
    codeGen.verifyArraySelector(index, errorToken2);
    if (a.getType() instanceof ArrayType)    {
      return new AttribImpl(((ArrayType)a.getType()).getElementType());    }    
    throw new SelectorNotArrayException(errorToken);  }}

Attrib ArrayLen() throws YAPLException :
{ Token t;
Token errorToken;
Attrib retVal; }{
  errorToken = "#" t = < IDENT >  {
    Symbol symbol = symbolTable.lookup(t.image);
    if (symbol.getKind() != SymbolKind.Variable && symbol.getKind() != SymbolKind.Parameter)
    	throw new SymbolIllegalUseException(symbol);
    //This is probably a bug
    if (!(symbol.getType() instanceof ArrayType))
    {
      throw new ArrayLenNotArrayException(errorToken);    }
    retVal = new AttribImpl(symbol.getType());  } (retVal = Selector(retVal))?
  {
    return new AttribImpl(new IntegerType());  }}
Attrib PrimaryExpr() throws YAPLException :
{
  Token t;
  Attrib retVal = null;
  Type type;
}{
  (type = Literal()  {
    return new AttribImpl(type);  } | "(" retVal = Expr() ")" | LOOKAHEAD(2) retVal = ProcedureCall(true) | t = < IDENT >
  {
    Symbol symbol = symbolTable.lookup(t.image);
    if (symbol.getKind() == SymbolKind.Procedure)    	throw new SymbolIllegalUseException(symbol);
    retVal = new AttribImpl(symbol.getType());  } (retVal = Selector(retVal))? | retVal = ArrayLen())

  {
    return retVal;  }}
Attrib ProcedureCall(boolean isFunction) throws YAPLException :
{ Token t;
Attrib retVal;
int argumentCount = 0;
Token errorToken; }
{
  t = < IDENT >
  {
    Symbol symbol = symbolTable.lookup(t.image);
    if (symbol.getKind() != SymbolKind.Procedure)
    	throw new SymbolIllegalUseException(symbol);
    if (isFunction && symbol.getType() == null)
    	throw new ProcNotFuncExprException(symbol);
    retVal = new AttribImpl(symbol.getType());  } "(" (argumentCount = ArgumentList(symbol))? errorToken = ")"

  {
    if (symbol.getParameters().size() != argumentCount)
    	throw new TooFewArgsException(symbol, errorToken);
    return retVal;  }}
int ArgumentList(Symbol s) throws YAPLException:
{
	int argumentCount = 1;
	List<Symbol> parameters = s.getParameters();
	Attrib arg;
}
{
  arg = Expr()
  {
    if ((parameters.size() < argumentCount) || (!parameters.get(argumentCount-1).getType().isCompatible(arg.getType())))
    	throw new ArgNotApplicableException(argumentCount, s, token);  } ("," arg = Expr()  {
    argumentCount++;
    if ((parameters.size() < argumentCount) || (!parameters.get(argumentCount-1).getType().isCompatible(arg.getType())))
    	throw new ArgNotApplicableException(argumentCount, s, token);  })*
  {
    return argumentCount;  }}
Attrib UnaryExpr () throws YAPLException:
{
  Token t = null;
  Attrib op;
}
{
  (t = AddOp())? op = PrimaryExpr()
  {
    return codeGen.op1(t, op);  }    }
Attrib MulExpr () throws YAPLException:
{
  Attrib retVal;
  Token t;
  Attrib op2;}
{
  (retVal = UnaryExpr()) (t = MulOp() op2 = UnaryExpr()
  {
    retVal = codeGen.op2(retVal, t, op2);  })*
  {
    return retVal;  }    }
Attrib AddExpr () throws YAPLException:
{
  Attrib retVal;
  Token t;
  Attrib op2;}
{
  retVal = MulExpr() (t = AddOp() op2 = MulExpr()  {
    retVal = codeGen.op2(retVal, t, op2);  })*
  {
    return retVal;   }}

Attrib RelExpr () throws YAPLException:
{
  Attrib retVal;
  Token t;
  Attrib op2;}
{
  retVal = AddExpr() (t = RelOp() op2 = AddExpr()
  {
    retVal = codeGen.relOp(retVal, t, op2);  })*
  {
    return retVal;  }}

Token AddOp () throws YAPLException:
{
  Token t;
}
{
  (t = "+" | t = "-")
  {
    return t;  }}

Token MulOp () throws YAPLException:
{
  Token t;}
{
  (t = "*" | t = "/" | t = "%")
  {
    return t;  }}

Token RelOp() throws YAPLException:
{Token t;}
{
   (t = "<" | t = "<=" | t = ">=" | t = ">")
   {
     return t;   }}

Token EqualOp() throws YAPLException :
{
  Token t;
}
{
    (t = "==" | t = "!=")
    {
      return t;    }}
Attrib EqualExpr () throws YAPLException:
{
  Attrib retVal;
  Token op;
  Attrib op2;
}
{
  retVal = RelExpr() (op = EqualOp() op2 = RelExpr()
  {
    retVal = codeGen.equalOp(retVal, op, op2);  })*
  {
    return retVal;  }}

Attrib CondAndExpr () throws YAPLException:
{
  Attrib retVal;
}
{
  retVal = EqualExpr() (< AND > EqualExpr())*
  {
    return retVal;  }}
Attrib Expr() throws YAPLException:
{
  Attrib retVal;
  Token op;
  Attrib op2;}{
  ((retVal = CondAndExpr() (op = < OR > op2 = CondAndExpr()
  {
    retVal = codeGen.op2(retVal, op, op2);   })*) | retVal = CreationExpr())
  {
    return retVal;  }}
Attrib CreationExpr() throws YAPLException:
{
  Attrib retVal;
  Type type;
  Token errorToken;
  Attrib index;
}{
  < NEW > (<INTEGER >  {
    type = new IntegerType();  }|< BOOLEAN >  {
    type = new BooleanType();  }) "[" index = Expr() errorToken = "]"  {
    codeGen.verifyArraySelector(index, errorToken);
    type = new ArrayType(type);  } ("[" index = Expr() errorToken = "]"  {
    codeGen.verifyArraySelector(index, errorToken);
    type = new ArrayType(type);  })*
  {
    return new AttribImpl(type);  }}

void ConstDecl() throws YAPLException :
{ Token t;
  Type type;
}{
  < CONST > t = <IDENT >
  {
    SymbolImpl sym = new SymbolImpl(t.image, SymbolKind.Constant);
    symbolTable.addSymbol(sym);  } "=" type = Literal()  {
    sym.setType(type);  } ";"}

void VarDecl() throws YAPLException :
{
  Token t;
  ArrayList<Symbol> symbols = new ArrayList<Symbol>();
  Symbol sym;
  Type type;
}{
  t = < IDENT >
  {
    sym = new SymbolImpl(t.image, Symbol.SymbolKind.Variable);
    symbols.add(sym);
    symbolTable.addSymbol(sym);  }
  ("," t = < IDENT >
  {
    sym = new SymbolImpl(t.image, Symbol.SymbolKind.Variable);
    symbols.add(sym);
    symbolTable.addSymbol(sym);  })* ":" type = Type() ";"
  {
    for(Symbol s : symbols)    {
      s.setType(type);     }  }}

void Decl() throws YAPLException :
{}
{
  < DECLARE > ( ConstDecl() | VarDecl() )*}

void Assignment() throws YAPLException :
{
  Token t;
  Attrib target;
  Attrib source;
}{
  t = < IDENT >  {
    Symbol symbol = symbolTable.lookup(t.image);
    target = new AttribImpl(symbol.getType());
    if (symbol.getKind() != SymbolKind.Variable && symbol.getKind() != SymbolKind.Parameter)
    	throw new SymbolIllegalUseException(symbol);  } (target = Selector(target))? t = ":=" source = Expr()
  {
    TypeMismatchAssignException.errorToken = t;
    codeGen.assign(target, source);  }}
void IfStatement() throws YAPLException :
{
  Attrib clause;
}
{
  < IF > clause = Expr()  {
    if (!(clause.getType() instanceof BooleanType))
      	throw new CondNotBoolException(token);  } < THEN > StatementList() (< ELSE > StatementList())? < ENDIF >}

void WhileStatement() throws YAPLException :
{
  Attrib clause;
}{
  < WHILE > clause = Expr()  {
    if (!(clause.getType() instanceof BooleanType))
      	throw new CondNotBoolException(token);  } < DO > StatementList() < ENDWHILE >}

void ReturnStatement() throws YAPLException :
{}{
  < RETURN > (Expr())?
  {
    Symbol s = symbolTable.getNearestParentSymbol(SymbolKind.Procedure);
    s.setReturnSeen(true);  }}

void WriteStatement() throws YAPLException :
{}{
  < WRITE > < STRING >}

void Statement() throws YAPLException :{}{
  IfStatement() | WhileStatement() | ReturnStatement() | WriteStatement() | LOOKAHEAD(2) Assignment() |
  ProcedureCall(false) | Block()}

void StatementList() throws YAPLException :
{}
{
  (Statement() ";")*}

void Block() throws YAPLException :
{
  Token errorSymbol;
}
{
  {
    symbolTable.openScope(false);  }
  (Decl())? < BEGIN > StatementList() errorSymbol = < END >
  {
    Symbol parent = symbolTable.getNearestParentSymbol(SymbolKind.Procedure);
    if (parent.getType() != null && !parent.getReturnSeen())
    	throw new MissingReturnException(parent, errorSymbol);
    symbolTable.closeScope();  }}

List<Symbol> FormalParam() throws YAPLException :
{
  Token t;
  Type type;
  Symbol sym;
  ArrayList<Symbol> symbols = new ArrayList<Symbol>();
}
{
  t = < IDENT >  {
    sym = new SymbolImpl(t.image, SymbolKind.Parameter);
    symbolTable.addSymbol(sym);
    symbols.add(sym);  }("," t = < IDENT >  {
    sym = new SymbolImpl(t.image, SymbolKind.Parameter);
    symbolTable.addSymbol(sym);
    symbols.add(sym);  })* ":" (< READONLY >)? type = Type()
  {
    for(Symbol s : symbols)
    {
      s.setType(type);    }
    return symbols;  }}

List<Symbol> FormalParamList() throws YAPLException :
{
  List<Symbol> parameters;
  List<Symbol> current;
}{
  parameters = FormalParam() (";" current = FormalParam()  {
    for(Symbol s : current)    {		parameters.add(s);
    }  })*
  {
    return parameters;  }}

void Procedure() throws YAPLException :
{ Token t;
Type type;
List<Symbol> parameters = null;
}
{
  < PROCEDURE > t = < IDENT >  {
    Symbol symbol = new SymbolImpl(t.image, SymbolKind.Procedure);
    symbolTable.addSymbol(symbol);
    symbolTable.openScope(false);
    symbolTable.setParentSymbol(symbol);  } "(" (parameters = FormalParamList())? ")"
  {
    if (parameters != null)
    	symbol.setParameters(parameters);  }
  (":" type = Type()  {
    symbol.setType(type);  })?
  Block() t = < IDENT >
  {
    Symbol parent = symbolTable.getNearestParentSymbol(SymbolKind.Procedure);
    if (!parent.getName().equals(t.image))    	throw new EndIdentifierMismatchException(parent, t.image); 
    symbolTable.closeScope();  }
  ";"}

void Program() throws YAPLException :
{}
{
  {
    Token t;
    Token x;  }
  < PROGRAM > t = <IDENT >  {
    Symbol symbol = new SymbolImpl(t.image, SymbolKind.Program);
    symbolTable.openScope(false);
    symbolTable.setParentSymbol(symbol);  } (Decl() | Procedure())*
  < BEGIN > StatementList() < END > x = <IDENT >
  {
    if (!t.image.equals(x.image))
    	throw new EndIdentifierMismatchException(symbol, x.image); 
    symbolTable.closeScope();  }
  "."}

void Start() throws YAPLException :{  Token t;}{
  {
    symbolTable.setDebug(false);  }
  (    Program()
  )*
  <EOF>}