/**** YAPL Compiler
*
*	Copyright 2010 Daniel Hölbling, Klagenfurt University
*
*	Licensed under the Apache License, Version 2.0 (the "License");
*	you may not use this file except in compliance with the License.
*	You may obtain a copy of the License at
*
*		http://www.apache.org/licenses/LICENSE-2.0
*       
*	Unless required by applicable law or agreed to in writing, software
*	distributed under the License is distributed on an "AS IS" BASIS,
*	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
*	See the License for the specific language governing permissions and
*	limitations under the License.
***/
options {
  JDK_VERSION = "1.5";
  static = true;
}
PARSER_BEGIN(yapl)
package yapl;
import yapl.interfaces.*;
import yapl.lib.*;
import java.util.*;
import yapl.exceptions.*;
import yapl.interfaces.Symbol.SymbolKind;
import yapl.types.*;
public class yapl {
  private static Symboltable symbolTable = new SymboltableImpl();
  private static CodeGen codeGen = new CodeGenImpl();

  public void clear()  {  	symbolTable = new SymboltableImpl();
  	codeGen = new CodeGenImpl();
  }
}
PARSER_END(yapl)

SKIP :
{
 	" "
|	"\r"
|	"\t"
|	"\n"
}

SPECIAL_TOKEN :
{
	< COMMENT : ("/*" (~["*"] | "*" ~["/"])* "*/") >
}

TOKEN:
{
  <# LETTER : (["A"-"Z"] | ["a"-"z"] | "_" ) > |
  <# DIGIT : (["0"-"9"]) > |
  <# OTHERCHAR: ("+" | "-" | "*" | "/" | "." | "," | ";" | ":" | "!"
| "?" | "=" | "#" | "%" | "<" | ">" | "$" | "(" | ")"
| "[" | "]" | "{" | "}" | "\\" | "@" | "&" | "^" | "|") >}



TOKEN :
{
  	< NEW: "new" > |
	< AND: "And" > |
	< OR: "Or" > |
	< DECLARE : "Declare" > |
	< PROGRAM : "Program" > |
	< BEGIN : "Begin" > |
	< END: "End" > |
	< IF : "If" > |
	< THEN : "Then" > |
	< ELSE : "Else" > |
	< ENDIF : "EndIf" > |
	< WHILE : "While" > |
	< CONST : "Const" > |
	< DO : "Do" > |
	< ENDWHILE : "EndWhile" > |
	< RETURN : "Return" > |
	< WRITE : "Write" > |
	< READONLY : "Readonly" > |
	< PROCEDURE : "Procedure" > |
	< TRUE : "True" > |
	< FALSE : "False" > |
	< INTEGER :  "Integer" > |
  	< BOOLEAN : "Boolean" > |	< IDENT : < LETTER > (< LETTER > | < DIGIT >)* > |
	< NUMBER: (< DIGIT >)+ > |
	< STRING: "\"" ( " " | < LETTER > | < DIGIT > | < OTHERCHAR > )* "\"" > 
}

Type Literal() throws YAPLException :
{
  Type t;}
{
  < TRUE >  {
    return new BooleanType();  } | < FALSE >
  {
    return new BooleanType();  } | < NUMBER >
  {
    return new IntegerType();  }}

void PredefinedProcedures() throws YAPLException :
{}
{
  (PredefProc())*}
void PredefProc() throws YAPLException :
{
  Token t;
}
{
  < PROCEDURE > t = < IDENT >
  {
    Symbol symbol = new SymbolImpl(t.image, Symbol.SymbolKind.Procedure);
    symbolTable.addSymbol(symbol);
    symbolTable.openScope(true);
  } "(" (FormalParamList())? ")"
  (":" Type())? ";"
  {
    symbolTable.closeScope();
  }}

Type Type() throws YAPLException :
{
  Type type;
}{
  (< INTEGER >  {    type = new IntegerType();  }  | < BOOLEAN >  {
    type = new BooleanType();  }) ( "[" "]")*
  {
    return type;  }}
void Selector() throws YAPLException :
{}
{
  "[" Expr() "]" (Selector())?}

void ArrayLen() throws YAPLException :
{ Token t; }{
  "#" t = < IDENT >  {
    Symbol symbol = symbolTable.lookup(t.image);
    if (symbol.getKind() != SymbolKind.Variable && symbol.getKind() != SymbolKind.Parameter)
    	throw new SymbolIllegalUseException(symbol);  } (Selector())?}
Attrib PrimaryExpr() throws YAPLException :
{
  Token t;
  Attrib retVal = null;
  Type type;
}{
  (type = Literal()  {
    return new AttribImpl(type);  } | "(" Expr() ")" | LOOKAHEAD(2) ProcedureCall() | t = < IDENT >
  {
    Symbol symbol = symbolTable.lookup(t.image);
    if (symbol.getKind() == SymbolKind.Procedure)    	throw new SymbolIllegalUseException(symbol);
    retVal = new AttribImpl(symbol.getType());  } (Selector())? | ArrayLen())

  {
    return retVal;  }}
void ProcedureCall() throws YAPLException :
{ Token t; }
{
  t = < IDENT >
  {
    Symbol symbol = symbolTable.lookup(t.image);
    if (symbol.getKind() != SymbolKind.Procedure)
    	throw new SymbolIllegalUseException(symbol);  } "(" (ArgumentList())? ")"}
void ArgumentList() throws YAPLException:
{}
{
  Expr() ("," Expr())*}
Attrib UnaryExpr () throws YAPLException:
{
  Token t = null;
  Attrib op;
}
{
  (t = AddOp())? op = PrimaryExpr()
  {
    return codeGen.op1(t, op);  }    }
Attrib MulExpr () throws YAPLException:
{
  Attrib retVal;
  Token t;
  Attrib op2;}
{
  (retVal = UnaryExpr()) (t = MulOp() op2 = UnaryExpr()
  {
    retVal = codeGen.op2(retVal, t, op2);  })*
  {
    return retVal;  }    }
Attrib AddExpr () throws YAPLException:
{
  Attrib retVal;
  Token t;
  Attrib op2;}
{
  retVal = MulExpr() (t = AddOp() op2 = MulExpr()  {
    retVal = codeGen.op2(retVal, t, op2);  })*
  {
    return retVal;   }}

Attrib RelExpr () throws YAPLException:
{
  Attrib retVal;
  Token t;
  Attrib op2;}
{
  retVal = AddExpr() (t = RelOp() op2 = AddExpr()
  {
    retVal = codeGen.relOp(retVal, t, op2);  })*
  {
    return retVal;  }}

Token AddOp () throws YAPLException:
{
  Token t;
}
{
  (t = "+" | t = "-")
  {
    return t;  }}

Token MulOp () throws YAPLException:
{
  Token t;}
{
  (t = "*" | t = "/" | t = "%")
  {
    return t;  }}

Token RelOp() throws YAPLException:
{Token t;}
{
   (t = "<" | t = "<=" | t = ">=" | t = ">")
   {
     return t;   }}

Token EqualOp() throws YAPLException :
{
  Token t;
}
{
    (t = "==" | t = "!=")
    {
      return t;    }}
Attrib EqualExpr () throws YAPLException:
{
  Attrib retVal;
  Token op;
  Attrib op2;
}
{
  retVal = RelExpr() (op = EqualOp() op2 = RelExpr()
  {
    retVal = codeGen.equalOp(retVal, op, op2);  })*
  {
    return retVal;  }}

void CondAndExpr () throws YAPLException:
{}
{
  EqualExpr() (< AND > EqualExpr())*}
void Expr() throws YAPLException:
{}{
  (CondAndExpr() (< OR > CondAndExpr())*) | CreationExpr()}
void CreationExpr() throws YAPLException:
{}{
  < NEW > (<INTEGER >|< BOOLEAN >) "[" Expr() "]" ("[" Expr() "]")*}

void ConstDecl() throws YAPLException :
{ Token t;
  Type type;
}{
  < CONST > t = <IDENT >
  {
    SymbolImpl sym = new SymbolImpl(t.image, SymbolKind.Constant);
    symbolTable.addSymbol(sym);  } "=" type = Literal()  {
    sym.setType(type);  } ";"}

void VarDecl() throws YAPLException :
{
  Token t;
  ArrayList<Symbol> symbols = new ArrayList<Symbol>();
  Symbol sym;
  Type type;
}{
  t = < IDENT >
  {
    sym = new SymbolImpl(t.image, Symbol.SymbolKind.Variable);
    symbols.add(sym);
    symbolTable.addSymbol(sym);  }
  ("," t = < IDENT >
  {
    sym = new SymbolImpl(t.image, Symbol.SymbolKind.Variable);
    symbolTable.addSymbol(sym);  })* ":" type = Type() ";"
  {
    for(Symbol s : symbols)    {
      s.setType(type);    }  }}

void Decl() throws YAPLException :
{}
{
  < DECLARE > ( ConstDecl() | VarDecl() )*}

void Assignment() throws YAPLException :
{
  Token t;
}{
  t = < IDENT >  {
    Symbol symbol = symbolTable.lookup(t.image);
    if (symbol.getKind() != SymbolKind.Variable && symbol.getKind() != SymbolKind.Parameter)
    	throw new SymbolIllegalUseException(symbol);  } (Selector())? ":=" Expr()}
void IfStatement() throws YAPLException :
{}
{
  < IF > Expr() < THEN > StatementList() (< ELSE > StatementList())? < ENDIF >}

void WhileStatement() throws YAPLException :
{}{
  < WHILE > Expr() < DO > StatementList() < ENDWHILE >}

void ReturnStatement() throws YAPLException :
{}{
  < RETURN > (Expr())?}

void WriteStatement() throws YAPLException :
{}{
  < WRITE > < STRING >}

void Statement() throws YAPLException :{}{
  IfStatement() | WhileStatement() | ReturnStatement() | WriteStatement() | LOOKAHEAD(2) Assignment() |
  ProcedureCall() | Block()}

void StatementList() throws YAPLException :
{}
{
  (Statement() ";")*}

void Block() throws YAPLException :
{}
{
  {
    symbolTable.openScope(false);  }
  (Decl())? < BEGIN > StatementList() < END >
  {
    symbolTable.closeScope();  }}

void FormalParam() throws YAPLException :
{
  Token t;
}
{
  t = < IDENT >  {
    symbolTable.addSymbol(new SymbolImpl(t.image, SymbolKind.Parameter));  }("," t = < IDENT >  {
    symbolTable.addSymbol(new SymbolImpl(t.image, SymbolKind.Parameter));  })* ":" (< READONLY >)? Type()}

void FormalParamList() throws YAPLException :
{}{
  FormalParam() (";" FormalParam())*}

void Procedure() throws YAPLException :
{ Token t; }
{
  < PROCEDURE > t = < IDENT >  {
    Symbol symbol = new SymbolImpl(t.image, SymbolKind.Procedure);
    symbolTable.addSymbol(symbol);
    symbolTable.openScope(false);
    symbolTable.setParentSymbol(symbol);  } "(" (FormalParamList())? ")"
  (":" Type())?
  Block() t = < IDENT >
  {
    Symbol parent = symbolTable.getNearestParentSymbol(SymbolKind.Procedure);
    if (!parent.getName().equals(t.image))    	throw new EndIdentifierMismatchException(parent, t.image); 
    symbolTable.closeScope();  }
  ";"}

void Program() throws YAPLException :
{}
{
  {
    Token t;
    Token x;  }
  < PROGRAM > t = <IDENT >  {
    Symbol symbol = new SymbolImpl(t.image, SymbolKind.Program);
    symbolTable.openScope(false);
    symbolTable.setParentSymbol(symbol);  } (Decl() | Procedure())*
  < BEGIN > StatementList() < END > x = <IDENT >
  {
    if (!t.image.equals(x.image))
    	throw new EndIdentifierMismatchException(symbol, x.image); 
    symbolTable.closeScope();  }
  "."}

void Start() throws YAPLException :{  Token t;}{
  {
    symbolTable.setDebug(false);  }
  (    Program()
  )*
  <EOF>}