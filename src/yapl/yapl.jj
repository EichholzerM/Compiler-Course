/**** YAPL Compiler
*
*	Copyright 2010 Daniel Hölbling, Klagenfurt University
*
*	Licensed under the Apache License, Version 2.0 (the "License");
*	you may not use this file except in compliance with the License.
*	You may obtain a copy of the License at
*
*		http://www.apache.org/licenses/LICENSE-2.0
*       
*	Unless required by applicable law or agreed to in writing, software
*	distributed under the License is distributed on an "AS IS" BASIS,
*	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
*	See the License for the specific language governing permissions and
*	limitations under the License.
***/
options {
  JDK_VERSION = "1.5";
  static = true;
}
PARSER_BEGIN(yapl)
package yapl;
import yapl.interfaces.*;
import yapl.lib.*;
import java.util.*;
import yapl.interfaces.Symbol.SymbolKind;
public class yapl {
  private static Symboltable symbolTable = new SymboltableImpl();

  public void clear()  {  	symbolTable = new SymboltableImpl();
  }
}
PARSER_END(yapl)

SKIP :
{
 	" "
|	"\r"
|	"\t"
|	"\n"
}

SPECIAL_TOKEN :
{
	< COMMENT : ("/*" (~["*"] | "*" ~["/"])* "*/") >
}

TOKEN:
{
  <# LETTER : (["A"-"Z"] | ["a"-"z"] | "_" ) > |
  <# DIGIT : (["0"-"9"]) > |
  <# OTHERCHAR: ("+" | "-" | "*" | "/" | "." | "," | ";" | ":" | "!"
| "?" | "=" | "#" | "%" | "<" | ">" | "$" | "(" | ")"
| "[" | "]" | "{" | "}" | "\\" | "@" | "&" | "^" | "|") >}



TOKEN :
{
  	< NEW: "new" > |
	< AND: "And" > |
	< OR: "Or" > |
	< DECLARE : "Declare" > |
	< PROGRAM : "Program" > |
	< BEGIN : "Begin" > |
	< END: "End" > |
	< IF : "If" > |
	< THEN : "Then" > |
	< ELSE : "Else" > |
	< ENDIF : "EndIf" > |
	< WHILE : "While" > |
	< CONST : "Const" > |
	< DO : "Do" > |
	< ENDWHILE : "EndWhile" > |
	< RETURN : "Return" > |
	< WRITE : "Write" > |
	< READONLY : "Readonly" > |
	< PROCEDURE : "Procedure" > |
  	< Literal: "True" | "False" | < NUMBER > > |
  	< PrimType : "Integer" | "Boolean" > |	< IDENT : < LETTER > (< LETTER > | < DIGIT >)* > |
	< NUMBER: (< DIGIT >)+ > |
	< STRING: "\"" ( " " | < LETTER > | < DIGIT > | < OTHERCHAR > )* "\"" > 
}

void PredefinedProcedures() throws YAPLException :
{}
{
  (PredefProc())*}
void PredefProc() throws YAPLException :
{
  Token t;
}
{
  < PROCEDURE > t = < IDENT >
  {
    Symbol symbol = new SymbolImpl(t.image, Symbol.SymbolKind.Procedure);
    symbolTable.addSymbol(symbol);
    symbolTable.openScope(true);
  } "(" (FormalParamList())? ")"
  (":" Type())? ";"
  {
    symbolTable.closeScope();
  }}

void Type() throws YAPLException :
{}{
  < PrimType > ( "[" "]")*}
void Selector() throws YAPLException :
{}
{
  "[" Expr() "]" (Selector())?}

void ArrayLen() throws YAPLException :
{ Token t; }{
  "#" t = < IDENT >  {
    Symbol symbol = symbolTable.lookup(t.image);
    if (symbol.getKind() != SymbolKind.Variable && symbol.getKind() != SymbolKind.Parameter)
    	throw new SymbolIllegalUseException(symbol);  } (Selector())?}
void PrimaryExpr() throws YAPLException :
{
  Token t;
}{
  (< Literal > | "(" Expr() ")" | LOOKAHEAD(2) ProcedureCall() | t = < IDENT >
  {
    Symbol symbol = symbolTable.lookup(t.image);
    if (symbol.getKind() == SymbolKind.Procedure)    	throw new SymbolIllegalUseException(symbol);  } (Selector())? | ArrayLen())}
void ProcedureCall() throws YAPLException :
{ Token t; }
{
  t = < IDENT >
  {
    Symbol symbol = symbolTable.lookup(t.image);
    if (symbol.getKind() != SymbolKind.Procedure)
    	throw new SymbolIllegalUseException(symbol);  } "(" (ArgumentList())? ")"}
void ArgumentList() throws YAPLException:
{}
{
  Expr() ("," Expr())*}
void UnaryExpr () throws YAPLException:
{}
{
  (AddOp())? PrimaryExpr()    }
void MulExpr () throws YAPLException:
{}
{
  (UnaryExpr()) (MulOp() UnaryExpr())*    }
void AddExpr () throws YAPLException:
{}
{
  MulExpr() (AddOp() MulExpr())*}

void RelExpr () throws YAPLException:
{}
{
  AddExpr() (RelOp() AddExpr())*}

void AddOp () throws YAPLException:
{}
{
  "+" | "-"}

void MulOp () throws YAPLException:
{}
{
  "*" | "/" | "%"}

void RelOp() throws YAPLException:
{}
{
   "<" | "<=" | ">=" | ">"}

void EqualOp() throws YAPLException :
{}
{
    "==" | "!="}
void EqualExpr () throws YAPLException:
{}
{
  RelExpr() (EqualOp() RelExpr())*}

void CondAndExpr () throws YAPLException:
{}
{
  EqualExpr() (< AND > EqualExpr())*}
void Expr() throws YAPLException:
{}{
  (CondAndExpr() (< OR > CondAndExpr())*) | CreationExpr()}
void CreationExpr() throws YAPLException:
{}{
  < NEW > < PrimType > "[" Expr() "]" ("[" Expr() "]")*}

void ConstDecl() throws YAPLException :
{ Token t; }{
  < CONST > t = <IDENT >
  {
    symbolTable.addSymbol(new SymbolImpl(t.image, SymbolKind.Constant));  } "=" < Literal > ";"}

void VarDecl() throws YAPLException :
{
  Token t;
  ArrayList<Token> tokens = new ArrayList<Token>(); 
}{
  t = < IDENT >
  {
    symbolTable.addSymbol(new SymbolImpl(t.image, Symbol.SymbolKind.Variable));  }
  ("," t = < IDENT >
  {
    symbolTable.addSymbol(new SymbolImpl(t.image, Symbol.SymbolKind.Variable));  })* ":" Type() ";"}

void Decl() throws YAPLException :
{}
{
  < DECLARE > ( ConstDecl() | VarDecl() )*}

void Assignment() throws YAPLException :
{
  Token t;
}{
  t = < IDENT >  {
    Symbol symbol = symbolTable.lookup(t.image);
    if (symbol.getKind() != SymbolKind.Variable && symbol.getKind() != SymbolKind.Parameter)
    	throw new SymbolIllegalUseException(symbol);  } (Selector())? ":=" Expr()}
void IfStatement() throws YAPLException :
{}
{
  < IF > Expr() < THEN > StatementList() (< ELSE > StatementList())? < ENDIF >}

void WhileStatement() throws YAPLException :
{}{
  < WHILE > Expr() < DO > StatementList() < ENDWHILE >}

void ReturnStatement() throws YAPLException :
{}{
  < RETURN > (Expr())?}

void WriteStatement() throws YAPLException :
{}{
  < WRITE > < STRING >}

void Statement() throws YAPLException :{}{
  IfStatement() | WhileStatement() | ReturnStatement() | WriteStatement() | LOOKAHEAD(2) Assignment() |
  ProcedureCall() | Block()}

void StatementList() throws YAPLException :
{}
{
  (Statement() ";")*}

void Block() throws YAPLException :
{}
{
  {
    symbolTable.openScope(false);  }
  (Decl())? < BEGIN > StatementList() < END >
  {
    symbolTable.closeScope();  }}

void FormalParam() throws YAPLException :
{
  Token t;
}
{
  t = < IDENT >  {
    symbolTable.addSymbol(new SymbolImpl(t.image, SymbolKind.Parameter));  }("," t = < IDENT >  {
    symbolTable.addSymbol(new SymbolImpl(t.image, SymbolKind.Parameter));  })* ":" (< READONLY >)? Type()}

void FormalParamList() throws YAPLException :
{}{
  FormalParam() (";" FormalParam())*}

void Procedure() throws YAPLException :
{ Token t; }
{
  < PROCEDURE > t = < IDENT >  {
    Symbol symbol = new SymbolImpl(t.image, SymbolKind.Procedure);
    symbolTable.addSymbol(symbol);
    symbolTable.openScope(false);
    symbolTable.setParentSymbol(symbol);  } "(" (FormalParamList())? ")"
  (":" Type())?
  Block() t = < IDENT >
  {
    Symbol parent = symbolTable.getNearestParentSymbol(SymbolKind.Procedure);
    if (!parent.getName().equals(t.image))    	throw new EndIdentifierMismatchException(parent, t.image); 
    symbolTable.closeScope();  }
  ";"}

void Program() throws YAPLException :
{}
{
  {
    Token t;
    Token x;  }
  < PROGRAM > t = <IDENT >  {
    Symbol symbol = new SymbolImpl(t.image, SymbolKind.Program);
    symbolTable.openScope(false);
    symbolTable.setParentSymbol(symbol);  } (Decl() | Procedure())*
  < BEGIN > StatementList() < END > x = <IDENT >
  {
    if (!t.image.equals(x.image))
    	throw new EndIdentifierMismatchException(symbol, x.image); 
    symbolTable.closeScope();  }
  "."}

void Start() throws YAPLException :{  Token t;}{
  {
    symbolTable.setDebug(false);  }
  (    Program()
  )*
  <EOF>}